#1. initiate onemap

library(onemap)

#2. load the data file (data_onemap.txt), using the function (read.outcross), and make a new file (redclover). The data is now as an object of class outcross. 

redclover<- read.outcross(file="redclover.txt",sep=",")

#3. to print to screen information about redclover. 

redclover

#4. estimate the recombination fraction between all pairs of markers, using two-point tests. 
#The LOD is set to 10, and recombination fraction maximum to 0.45. This also estimates the linkage phase of each marker. The data is now of an object of class rf.2pts.

twopts <- rf.2pts(redclover, LOD=10, max.rf=0.45)

#5. to print to screen information about twopts. 

twopts

#probably too much data here so to get information about markers type 

print(twopts, "RCS1150", "RCS5390")

#Each line corresponds to a possible linkage phase. 1 denotes coupling phase in both parents
#(CC), 2 and 3 denote coupling phase in parent 1 and 2, respectively, and repulsion in the
#other (CR and RC), and 4 denotes repulsion phase in both parents (RR). Theta is the
#maximum likelihood estimate of the recombination fraction, with its LOD Scores.

#6. assigning markers to linkage groups. 
#make.seq creates a sequence with the markers that are to be assigned from file twopts, and puts them into the file mark.all. 
#"all" indicates that all markers are to be used. teh data is now as an object of class sequence.

mark.all <-make.seq(twopts, "all")

#7. to identify marker number, name and type.  
#marker.type is the function to print to screen the markers in file marker.all. 

marker.type(mark.all)

#8. group the markers. this uses the previously defined thresholds for the object twopts. The data is now as an object of class group.

LGs <-group(mark.all, LOD=4,max.rf=0.4)

#9. print to screen detailed information about the groups, i.e., all linkage groups will be printed, displaying the names of markers in each one of them. 

LGs

#10. to  see  some  basic  information  (such  as  the  number  of groups, number of linked markers, etc). 

print(LGs, detailed=FALSE)

#11. genetic mapping of data. 
#to set the mapping function used to display the map.

set.map.fun(type="kosambi")

#12. define which linkage group to be mapped.  
#The linkage group must be "extracted" from the object of class group, in order to be mapped.  The first argument (LGs) is an object of class group and the second is a 
#number indicating which linkage group will be extracted, according to the results stored in object LGs.  The object LG1, generated by function make.seq, is of class sequence.
#Can we set up a loop here to run all 7 groups simultaneously?  Script here uses just LG1 for simplicity.

LG1 <-make.seq(LGs, 1)

#13. to see which markers are in LG1. 

LG1

#14. order the markers using a two-point based algorithm : recombination counting and ordering.
LG1.rec <- record(LG1)

#15. use marker.type function to check the segregation types of all the markers in LG. 

marker.type(LG1)

#16. The next command uses the most informative markers. In this case the most informative markers are thoes that are scored as A1, A2, B3 markers. 
#There are others which are scored as D1.10 and D2.15, these are not as informative. 
#the command line has been written to take the markers in line order using a command eg as c(4, 19, 34, 95) where c=line number. 
#the command marker.type(LG1) should give us the information we need to find the line corresponding to each marker. 
#The commands from here are writen given the assumption we know which line the informative markers are on. 
#the c numbers are arbitary in the next command.

LG1.init <-make.seq(twopts, c(1, 4, 7, 9, 12, 15, 20, 23))
LG1.comp <-compare(LG1.init)
LG1.comp

#17. the first argument to make.seq is an object of rf.2pts, the second is a vector of integers, detailing which markers will be in the sequence.
#Remember that for outcrossing populations, one needs to estimate marker order and also
#linkage phases between markers for a given order. However, since two point analysis also
#provided information about linkage phases, this information was taken into consideration
#in the compare function, reducing the number of combinations to be evaluated. If at least
#one linkage phase has LOD equals to 0.005 in the two point analysis, we assumed that
#this phase is very unlikely and so do not need to be evaluated in the multipoint procedure
#used by compare. We did extensive simulations that showed that this is a good procedure.
#By default, OneMap stores 50 orders, which may or may not be unique. The value of
#LOD refers to the overall LOD Score, considering all orders tested. Nested LOD refers to
#LOD Scores within a given order, i.e., scores for different combinations of linkage phases
#for the same marker order.
#For example, order 1 has the largest value of log-likelihood and, therefore, its LOD Score is
#zero for a given combination of linkage phases (CC, CC, RR, RR). For this same order and
#other linkage phases, LOD Score is -2.43. Analyzing the results for order 2, notice that its
#highest LOD Score is very close to zero, indicating that this order is also quite plausible.
#Notice also that Nested LOD will always contain at least one zero value, corresponding
#to the best combination of phases for markers in a given order. Due to the information
#provided by two-point analysis, not all combinations are tested and that is the reason
#why the number of Nested LOD is different for each order.

#18. select the best order.

LG1.frame <-make.seq(LG1.comp)

#19. the remaining markers can now be added sequentially using the function order.seq. 
#the function n.init=8 indicated the 8 most informative markers, it should in fact be the same number as the informative markers identified above. 
#THRES=3 indicates that markers with a LOD score above 3 will be mapped. this step is most useful when there are many infromative markers. 
#The order.seq function can also perform two rounds of try.seq algorithms, first using THRES and then THRES - 1 as threshold.  This generally results in safe orders with more markers mapped, but may take longer to run.  
#To do this use the touchdown options.

LG1.ord <- order.seq(LG1, n.init=8, THRES=3, touchdown=TRUE)

#check the final order. Again will print to screen.

LG1.ord

#20. this may not map all of the markers if the LOD score > THRES in absolute value. the output will display the 'safe' order and the most likely position of the unmapped markers. 
#thsi is indicated by *** - most likely position, * other plausible positions. to get a safe order:

LG1.safe <-make.seq(LG1.ord,"safe")

#21. Again will print to screen.
LG1.safe

#22. to force all markers into a linkage group

LG1.all <-make.seq(LG1.ord,"force")

#23. Again will print to screen.
LG1.all

#24. we are actually interested in the LG.safe markers, so do a ripple command to shuffle the markers to find potantial alternative orders for each marker.  
#this can also be done on the LG1.all data. will print to screeen some of the linkage phase data.

ripple.seq(LG1.safe, ws=4, LOD=3)

#25. if the final order is the best (and is most likely), print the map 

LG1.safe
LG1.safe$seq.num
LG1.safe$seq.phase
LG1.final <-ripple.seq(LG1.safe)

#26. plotting the recombination fraction matrix. 
#For a given sequence, it is possible to plot the recombination fraction matrix and LOD Scores based on a color scale using the function rf.graph.table.  
#This matrix can be useful to make some diagnostics about the map.

(LGs <-group(mark.all, LOD=3))

#27. order the markers

LG1.err<-make.seq(LGs, 1)
LG1.err.ord<-order.seq(LG1.err)

#then map using both safe and forse options

(LG1.err.map<-make.seq(LG1.err.ord,"safe"))

#28. this may show up errors in the map. this can be sen by plotting the recombination fraction matrix
library(tcltk)
rf.graph.table(LG1.err.map)

#29. The  recombination  fractions  are  plotted  below  the  diagonal  and  the  LOD  Scores  are plotted above the diagonal.  
#The color scale varies from red (small distances or big LODs) to dark blue.  
#This color scale follows the \rainbow" color palette with start argument equals to 0 and end argument equals to 0.65.  
#White cells indicate for combinations of markers whose recombination fractions cannot be estimated (D1 and D2), 
#we should see many white spaces as the majority of the data are D1 and D2 markers.


#30. drawing the genetic map. 
#once all the genetic maps have been obtained a simple map can be drawn using draw.map function.

maps<-list(LG1.final, LG2.final, LG3.final, LG4.final, LG5.final, LG6.final, LG7.final)
draw.map(maps, names= TRUE, grid= TRUE, cex.mrk=0.7)

#31. for one LG

draw.map(LG1.safe, names= TRUE, grid=TRUE, cex.mrk=0.7)

#32. these are very simple maps, better ones can be drawn in MapChart, from the files LG1.final etc

#33. save and export files
write.map(LG1.safe, "LG1.safe.map")
#saves as joinmap format file which can be used in r/qtl
write.table(LG1.safe$seq.phases, "LG1.safe.map.phase.txt")
write.table(LG1.safe$seq.num, "LG1.safe.map.num.txt")
